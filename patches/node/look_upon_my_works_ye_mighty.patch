From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Shelley Vohr <shelley.vohr@gmail.com>
Date: Tue, 14 Nov 2023 18:47:53 +0100
Subject: look upon my works ye mighty

and dispair

diff --git a/BUILD.gn b/BUILD.gn
index 37879871fc7d5a1934e76800a27816861e7b8c89..f82caa5eb96ba7c2d8d667d8a2c129b687c945b2 100644
--- a/BUILD.gn
+++ b/BUILD.gn
@@ -93,7 +93,7 @@ chdir_action("node_js2c_exec") {
 
   cwd = "$target_gen_dir/js2c_inputs"
   script = "$root_out_dir/node_js2c"
-  args = library_files + rebase_path(config_gypi) + ["--target"] + rebase_path(outputs)
+  args = rebase_path(outputs) + library_files + rebase_path(config_gypi)
 }
 
 config("node_features") {
@@ -211,15 +211,18 @@ executable("node_js2c") {
     "tools/executable_wrapper.h"
   ]
   include_dirs = [ "tools" ]
-  deps = [ "deps/simdutf", "deps/uv" ]
+  deps = [
+    "deps/simdutf",
+    "deps/uv",
+    "//base",
+    "//v8"
+  ]
+
   if (!is_win) {
     defines += [ "NODE_JS2C_USE_STRING_LITERALS" ]
   }
   if (is_debug) {
-    cflags_cc = [
-      "-g",
-      "-O0",
-    ]
+    cflags_cc = [ "-g", "-O0" ]
     defines += [ "DEBUG" ]
   }
 }
diff --git a/lib/internal/modules/esm/utils.js b/lib/internal/modules/esm/utils.js
index 524558b6d00969c2b62cd6050fde9de583f14e90..356c10aef57454be3b4607156606784f473042cf 100644
--- a/lib/internal/modules/esm/utils.js
+++ b/lib/internal/modules/esm/utils.js
@@ -16,7 +16,7 @@ const {
   ERR_VM_DYNAMIC_IMPORT_CALLBACK_MISSING,
   ERR_INVALID_ARG_VALUE,
 } = require('internal/errors').codes;
-const { getOptionValue } = require('internal/options');
+const { getOptionValue, getEmbedderOptions } = require('internal/options');
 const {
   loadPreloadModules,
   initializeFrozenIntrinsics,
diff --git a/src/module_wrap.h b/src/module_wrap.h
index c51eb99ce3eb54bc30ae922e0357b637b09d53c6..55317ced78ee9ceaa13f7e00477c59370eb335fa 100644
--- a/src/module_wrap.h
+++ b/src/module_wrap.h
@@ -7,6 +7,7 @@
 #include <string>
 #include <vector>
 #include "base_object.h"
+#include "node.h"
 
 namespace node {
 
diff --git a/src/node_builtins.cc b/src/node_builtins.cc
index b9598eff8acd8390007be0a09ac019b488ce0855..77386bd234d0b49b122f1de3d27b1a92da5d0ea4 100644
--- a/src/node_builtins.cc
+++ b/src/node_builtins.cc
@@ -751,6 +751,7 @@ void BuiltinLoader::RegisterExternalReferences(
   registry->Register(GetNatives);
 
   RegisterExternalReferencesForInternalizedBuiltinCode(registry);
+  EmbedderRegisterExternalReferencesForInternalizedBuiltinCode(registry);
 }
 
 }  // namespace builtins
diff --git a/src/node_builtins.h b/src/node_builtins.h
index 9e76bc2c9b7031dde9b1497125c4af608e55d54c..b995e15fcd795f310126a38ec652efcd9fd36945 100644
--- a/src/node_builtins.h
+++ b/src/node_builtins.h
@@ -74,6 +74,8 @@ using BuiltinCodeCacheMap =
 // Generated by tools/js2c.py as node_javascript.cc
 void RegisterExternalReferencesForInternalizedBuiltinCode(
     ExternalReferenceRegistry* registry);
+void EmbedderRegisterExternalReferencesForInternalizedBuiltinCode(
+    ExternalReferenceRegistry* registry);
 
 // Handles compilation and caching of built-in JavaScript modules and
 // bootstrap scripts, whose source are bundled into the binary as static data.
diff --git a/tools/js2c.cc b/tools/js2c.cc
index 9a19b9227e148d65e81bf2dfb638d260c51782ca..c5ce708f68f0732afb01587c41fdea2e09522785 100755
--- a/tools/js2c.cc
+++ b/tools/js2c.cc
@@ -16,6 +16,8 @@
 #include "simdutf.h"
 #include "uv.h"
 
+#include "base/strings/string_util.h"
+
 #if defined(_WIN32)
 #include <io.h>  // _S_IREAD _S_IWRITE
 #ifndef S_IRUSR
@@ -146,6 +148,7 @@ bool SearchFiles(const std::string& dir,
   }
 
   uv_fs_req_cleanup(&scan_req);
+  fprintf(stderr, "SearchFiles %s %s\n", dir.c_str(), errored ? "failed" : "ok");
   return !errored;
 }
 
@@ -215,17 +218,46 @@ void BuiltinLoader::LoadJavaScriptSource() {
   source_ = global_source_map;
 }
 
-void BuiltinLoader::LoadEmbedderJavaScriptSource() {
-  source_ = global_source_map;
-}
-
 void RegisterExternalReferencesForInternalizedBuiltinCode(
   ExternalReferenceRegistry* registry) {
 %.*s
 }
 
 UnionBytes BuiltinLoader::GetConfig() {
-  return config_resource ? UnionBytes(&config_resource) : UnionBytes(nullptr);
+  return UnionBytes(&config_resource);
+}
+
+}  // namespace builtins
+
+}  // namespace node
+)";
+
+const char* kEmbedderTemplate = R"(
+#include "env-inl.h"
+#include "node_builtins.h"
+#include "node_external_reference.h"
+#include "node_internals.h"
+
+namespace node {
+
+namespace builtins {
+
+%.*s
+namespace {
+const ThreadsafeCopyOnWrite<BuiltinSourceMap> global_source_map {
+  BuiltinSourceMap {
+%.*s
+  }  // BuiltinSourceMap
+};  // ThreadsafeCopyOnWrite
+}  // anonymous namespace
+
+void BuiltinLoader::LoadEmbedderJavaScriptSource() {
+  source_ = global_source_map;
+}
+
+void EmbedderRegisterExternalReferencesForInternalizedBuiltinCode(
+  ExternalReferenceRegistry* registry) {
+%.*s
 }
 
 }  // namespace builtins
@@ -248,7 +280,7 @@ Fragment Format(const Fragments& definitions,
   std::vector<char> result(result_size, 0);
   int r = snprintf(result.data(),
                    result_size,
-                   kTemplate,
+                   only_js ? kEmbedderTemplate: kTemplate,
                    static_cast<int>(def_buf.size()),
                    def_buf.data(),
                    static_cast<int>(init_buf.size()),
@@ -720,49 +752,53 @@ int JS2C(const FileList& js_files,
 
     // Electron: Expose fs module without asar support.
     if (filename == "lib/fs.js") {
-      int error = 0;
-      if (error != 0 && error != UV_ENOENT)
-        return error;
-
-      // std::function<std::vector<char>(const std::vector<char>&)> ReadFileTransform = [](const char* path, size_t size, int* error) {
-      //   std::vector<char> code = ReadFileSync(path, size, &error);
-      //   std::replace(code.begin(), code.end(), "require('internal/fs/", "require('internal/original-fs/");
-      //   return code;
-      // };
-      int rr = AddModule("lib/original-fs.js", &definitions, &initializers, &registrations, std::nullopt);
-      if (rr != 0) {
-        return rr;
-      }
-    } else if (filename.rfind("lib/internal/fs/")) {
-      // std::equal(prefix.begin(), prefix.end(), toCheck.begin())?
-      std::string original_fs_filename = filename;
-      original_fs_filename = std::regex_replace(original_fs_filename, std::regex("internal/fs/"), "internal/original-fs/");
+      // int error = 0;
+      // if (error != 0 && error != UV_ENOENT)
+      //   return error;
+
+      // r = AddModule("lib/original-fs.js", &definitions, &initializers, &registrations, std::nullopt);
+      // if (r != 0) {
+      //   fprintf(stderr, "OH NO %d\n", __LINE__);
+      //   return r;
+      // }
+    } else if (filename.rfind("lib/internal/fs/") != std::string::npos) {
+      // std::string original_fs_filename = filename;
+      // original_fs_filename = std::regex_replace(original_fs_filename, std::regex("internal/fs/"), "internal/original-fs/");
  
-      std::function<std::vector<char>(std::vector<char>)> ReadFileTransform = [](std::vector<char> code) {
-        bool is_one_byte = simdutf::validate_ascii(code.data(), code.size());
-        if (is_one_byte) {
-          std::string str(code.begin(), code.end());
-          str = std::regex_replace(str, std::regex("internal/fs/"), "internal/original-fs/");
-          return std::vector<char>(str.begin(), str.end());
-        } else {
-          std::u16string str(code.begin(), code.end());
-          std::string base = "internal/fs/";
-          std::string replace = "internal/original-fs/";
-          char16_t wide_base;
-          size_t base_size = simdutf::convert_utf8_to_utf16(base.c_str(), base.size(), &wide_base);
-          char16_t wide_replace;
-          size_t replace_size = simdutf::convert_utf8_to_utf16(replace.c_str(), replace.size(), &wide_replace);
-          str = std::regex_replace(str, std::basic_regex<char16_t>(std::u16string(wide_base, base_size)), std::u16string(wide_replace, replace_size));
-          return std::vector<char>(str.begin(), str.end());
-        }
-        // std::replace(code.begin(), code.end(), "require('fs')", "require('original-fs')");
-        // return code;
-      };
-
-      int rrr = AddModule(original_fs_filename, &definitions, &initializers, &registrations, &ReadFileTransform);
-      if (rrr != 0) {
-        return rrr;
-      };
+      // std::function<std::vector<char>(std::vector<char>)> ReadFileTransform = [](std::vector<char> code) {
+      //   bool is_one_byte = simdutf::validate_ascii(code.data(), code.size());
+
+      //   if (is_one_byte) {
+      //     fprintf(stderr, "OH NO %d\n", __LINE__);
+      //     std::string str(code.begin(), code.end());
+
+      //     std::string to_replace = "internal/fs/";
+      //     std::string replacement = "internal/original-fs/";
+
+      //     str = std::regex_replace(str, std::regex(to_replace), replacement);
+      //     return std::vector<char>(str.begin(), str.end());
+      //   } else {
+      //     fprintf(stderr, "OH NO %d\n", __LINE__);
+      //     std::u16string str(code.begin(), code.end());
+
+      //     std::u16string to_replace(u"internal/fs/");
+      //     std::u16string replacement(u"internal/original-fs/");
+
+      //     bool success = base::ReplaceChars(str, to_replace, replacement, &str);
+
+      //     if (!success) {
+      //       fprintf(stderr, "OOPS\n");
+      //     }
+
+      //     return std::vector<char>(str.begin(), str.end());
+      //   }
+      // };
+
+      // r = AddModule(original_fs_filename, &definitions, &initializers, &registrations, ReadFileTransform);
+      // if (r != 0) {
+      //   fprintf(stderr, "OH NO %d\n", __LINE__);
+      //   return r;
+      // };
     }
   }
   for (const auto& filename : mjs_files) {
@@ -831,6 +867,7 @@ int Main(int argc, char* argv[]) {
       return 1;
     }
   }
+
   std::string output = args[0];
 
   FileMap file_map;
@@ -856,14 +893,18 @@ int Main(int argc, char* argv[]) {
     }
   }
 
-  auto js_it = file_map.find(".js");
-  auto mjs_it = file_map.find(".mjs");
-  auto gypi_it = file_map.find(".gypi");
-
   if (only_js) {
+    auto js_it = file_map.find(".js");
+
     assert(file_map.size() == 1);
     assert(js_it != file_map.end());
+
+    return JS2C(js_it->second, FileList(), std::string(), output);
   } else {
+    auto js_it = file_map.find(".js");
+    auto mjs_it = file_map.find(".mjs");
+    auto gypi_it = file_map.find(".gypi");
+
     // Should have exactly 3 types: `.js`, `.mjs` and `.gypi`.
     assert(file_map.size() == 3);
     assert(js_it != file_map.end() && mjs_it != file_map.end());
@@ -879,9 +920,9 @@ int Main(int argc, char* argv[]) {
           "Arguments should contain one and only one .gypi file: config.gypi\n");
       return 1;
     }
-  }
 
-  return JS2C(js_it->second, mjs_it->second, gypi_it->second[0], output);
+    return JS2C(js_it->second, mjs_it->second, gypi_it->second[0], output);
+  }
 }
 }  // namespace js2c
 }  // namespace node
